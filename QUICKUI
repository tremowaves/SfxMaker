import { useState, useEffect, useRef } from 'react';
import * as Tone from 'tone';
import { Play, Plus, X, ChevronUp, ChevronDown, StopCircle } from 'lucide-react';

export default function QuickUI() {
  // State để lưu trữ danh sách âm thanh
  const [audioTracks, setAudioTracks] = useState([]);
  // State để lưu trữ preset types
  const [showTypeDropdown, setShowTypeDropdown] = useState(false);
  const [selectedTrackIndex, setSelectedTrackIndex] = useState(null);
  // State để lưu trữ trạng thái playing
  const [playingState, setPlayingState] = useState({});
  // State để lưu trữ pitch variation
  const [pitchVariation, setPitchVariation] = useState({});
  // State để lưu trữ số lần lặp
  const [loopCount, setLoopCount] = useState({});
  
  // Refs để truy cập các player âm thanh
  const playerRefs = useRef({});
  
  // Các loại âm thanh
  const soundTypes = [
    "SfxFootstep",
    "SfxWeapon",
    "SfxEnvironment",
    "UIMain",
    "Bgm",
    "Sfx Character"
  ];

  // Hiệu ứng để khởi tạo Tone.js
  useEffect(() => {
    Tone.start();
    return () => {
      // Dọn dẹp khi component unmount
      Object.values(playerRefs.current).forEach(player => {
        if (player) player.dispose();
      });
    };
  }, []);

  // Hàm để xử lý upload file âm thanh
  const handleFileUpload = async (e) => {
    const file = e.target.files[0];
    if (!file) return;
    
    try {
      // Đọc file và tạo AudioBuffer
      const arrayBuffer = await file.arrayBuffer();
      const audioContext = new AudioContext();
      const decodedBuffer = await audioContext.decodeAudioData(arrayBuffer);
      
      // Tạo buffer Tone.js
      const buffer = new Tone.Buffer().fromArray(
        decodedBuffer.getChannelData(0),
        decodedBuffer.sampleRate
      );
      
      // Tạo track mới
      const newTrack = {
        id: Date.now().toString(),
        name: file.name,
        type: '',
        buffer,
        volume: -10,
        pitch: 0,
        playCount: 1,
        mixed: false
      };
      
      setAudioTracks(prev => [...prev, newTrack]);
      setLoopCount(prev => ({ ...prev, [newTrack.id]: 1 }));
      
      // Tạo player mới cho track này
      const player = new Tone.Player(buffer).toDestination();
      player.volume.value = -10; // Mặc định volume
      
      // Lưu player vào refs
      playerRefs.current[newTrack.id] = player;
    } catch (error) {
      console.error("Error loading audio file:", error);
      alert("Không thể tải file âm thanh. Vui lòng thử lại với file khác.");
    }
  };

  // Hàm để phát một âm thanh
  const playSound = (trackId) => {
    const player = playerRefs.current[trackId];
    if (!player) return;
    
    const track = audioTracks.find(t => t.id === trackId);
    if (!track) return;
    
    // Dừng nếu đang phát
    if (playingState[trackId]) {
      player.stop();
      setPlayingState(prev => ({ ...prev, [trackId]: false }));
      return;
    }
    
    // Phát âm thanh với số lần lặp lại
    let playCount = 0;
    const playNext = () => {
      if (playCount < loopCount[trackId]) {
        player.start();
        playCount++;
        setPlayingState(prev => ({ ...prev, [trackId]: true }));
        
        player.onstop = () => {
          if (playCount < loopCount[trackId]) {
            playNext();
          } else {
            setPlayingState(prev => ({ ...prev, [trackId]: false }));
          }
        };
      }
    };
    
    playNext();
  };

  // Hàm để dừng âm thanh
  const stopSound = (trackId) => {
    const player = playerRefs.current[trackId];
    if (player) {
      player.stop();
      setPlayingState(prev => ({ ...prev, [trackId]: false }));
    }
  };

  // Hàm để tăng số lần lặp
  const increaseLoopCount = (trackId) => {
    setLoopCount(prev => ({
      ...prev,
      [trackId]: (prev[trackId] || 1) + 1
    }));
  };

  // Hàm để giảm số lần lặp
  const decreaseLoopCount = (trackId) => {
    setLoopCount(prev => ({
      ...prev,
      [trackId]: Math.max(1, (prev[trackId] || 1) - 1)
    }));
  };

  // Hàm để thêm variation cho pitch
  const addPitchVariation = (trackId, amount) => {
    setPitchVariation(prev => ({ ...prev, [trackId]: amount }));
    
    const player = playerRefs.current[trackId];
    if (player) {
      player.pitch = amount;
    }
  };

  // Hàm để phát tất cả các âm thanh
  const playAllSounds = () => {
    audioTracks.forEach(track => {
      const player = playerRefs.current[track.id];
      if (player) {
        player.start();
        setPlayingState(prev => ({ ...prev, [track.id]: true }));
        
        player.onstop = () => {
          setPlayingState(prev => ({ ...prev, [track.id]: false }));
        };
      }
    });
  };

  // Hàm để export một âm thanh dưới dạng WAV
  const exportSound = async (trackId) => {
    const track = audioTracks.find(t => t.id === trackId);
    if (!track) return;
    
    try {
      // Tạo context offline để render âm thanh
      const offlineContext = new OfflineAudioContext({
        numberOfChannels: 2,
        length: 44100 * 5, // 5 giây
        sampleRate: 44100,
      });
      
      // Tạo source từ buffer
      const source = offlineContext.createBufferSource();
      source.buffer = await Tone.getContext().rawContext.decodeAudioData(track.buffer.get().arrayBuffer);
      
      // Tạo gain node để điều chỉnh volume
      const gainNode = offlineContext.createGain();
      gainNode.gain.value = Math.pow(10, track.volume / 20); // Convert dB to linear gain
      
      // Tạo pitch shift node nếu có variation
      if (pitchVariation[trackId]) {
        const pitchShift = offlineContext.createBiquadFilter();
        pitchShift.type = 'peaking';
        pitchShift.frequency.value = 1000;
        pitchShift.Q.value = 1;
        pitchShift.gain.value = pitchVariation[trackId] * 100;
        source.connect(pitchShift);
        pitchShift.connect(gainNode);
      } else {
        source.connect(gainNode);
      }
      
      gainNode.connect(offlineContext.destination);
      
      // Bắt đầu render
      source.start(0);
      const renderedBuffer = await offlineContext.startRendering();
      
      // Chuyển đổi sang WAV và download
      const wavBlob = bufferToWav(renderedBuffer);
      const fileName = track.name.replace(/\.[^/.]+$/, "") + "_processed.wav";
      
      // Tạo download link
      const downloadLink = document.createElement("a");
      downloadLink.href = URL.createObjectURL(wavBlob);
      downloadLink.download = fileName;
      document.body.appendChild(downloadLink);
      downloadLink.click();
      document.body.removeChild(downloadLink);
    } catch (error) {
      console.error("Error exporting sound:", error);
      alert("Error exporting sound. Please try again.");
    }
  };

  // Hàm để chuyển đổi AudioBuffer sang WAV
  const bufferToWav = (buffer) => {
    const numberOfChannels = buffer.numberOfChannels;
    const sampleRate = buffer.sampleRate;
    const format = 1; // PCM
    const bitDepth = 16;
    
    // Tính toán kích thước dữ liệu âm thanh
    const dataLength = buffer.length * numberOfChannels * (bitDepth / 8);
    const buffer2 = new ArrayBuffer(44 + dataLength);
    const view = new DataView(buffer2);
    
    // Viết header WAV
    writeString(view, 0, "RIFF");
    view.setUint32(4, 36 + dataLength, true);
    writeString(view, 8, "WAVE");
    
    // Viết subchunk "fmt"
    writeString(view, 12, "fmt ");
    view.setUint32(16, 16, true);
    view.setUint16(20, format, true);
    view.setUint16(22, numberOfChannels, true);
    view.setUint32(24, sampleRate, true);
    view.setUint32(28, sampleRate * numberOfChannels * (bitDepth / 8), true);
    view.setUint16(32, numberOfChannels * (bitDepth / 8), true);
    view.setUint16(34, bitDepth, true);
    
    // Viết subchunk "data"
    writeString(view, 36, "data");
    view.setUint32(40, dataLength, true);
    
    // Viết dữ liệu âm thanh
    const channels = [];
    for (let i = 0; i < numberOfChannels; i++) {
      channels.push(buffer.getChannelData(i));
    }
    
    let offset = 44;
    for (let i = 0; i < buffer.length; i++) {
      for (let channel = 0; channel < numberOfChannels; channel++) {
        const sample = Math.max(-1, Math.min(1, channels[channel][i]));
        const int16 = sample < 0 ? sample * 0x8000 : sample * 0x7FFF;
        view.setInt16(offset, int16, true);
        offset += 2;
      }
    }
    
    return new Blob([buffer2], { type: "audio/wav" });
  };

  // Hàm hỗ trợ để viết chuỗi vào DataView
  const writeString = (view, offset, string) => {
    for (let i = 0; i < string.length; i++) {
      view.setUint8(offset + i, string.charCodeAt(i));
    }
  };

  // Hàm để xử lý khi người dùng xóa một track
  const removeTrack = (trackId) => {
    // Xóa player
    if (playerRefs.current[trackId]) {
      playerRefs.current[trackId].dispose();
      delete playerRefs.current[trackId];
    }
    
    // Xóa track khỏi state
    setAudioTracks(prev => prev.filter(track => track.id !== trackId));
    
    // Xóa trạng thái playing
    setPlayingState(prev => {
      const newState = { ...prev };
      delete newState[trackId];
      return newState;
    });
  };

  // Hàm để chọn type cho track
  const selectType = (trackId, type) => {
    setAudioTracks(prev => 
      prev.map(track => 
        track.id === trackId ? { ...track, type } : track
      )
    );
    setShowTypeDropdown(false);
  };

  // Hàm để cập nhật volume của track
  const updateVolume = (trackId, value) => {
    // Cập nhật state
    setAudioTracks(prev => 
      prev.map(track => 
        track.id === trackId ? { ...track, volume: value } : track
      )
    );
    
    // Cập nhật player
    if (playerRefs.current[trackId]) {
      playerRefs.current[trackId].volume.value = value;
    }
  };

  // Hàm để cập nhật số lần phát
  const updatePlayCount = (trackId, value) => {
    setAudioTracks(prev => 
      prev.map(track => 
        track.id === trackId ? { ...track, playCount: value } : track
      )
    );
  };

  // Hàm để kích hoạt chế độ mix
  const activateMixMode = (trackId) => {
    setAudioTracks(prev => 
      prev.map(track => 
        track.id === trackId ? { ...track, mixed: true } : track
      )
    );
  };

  // Hiển thị ứng dụng
  return (
    <div className="max-w-5xl mx-auto p-4 bg-gray-50 min-h-screen">
      <div className="bg-green-50 py-4 px-6 rounded-md mb-6 text-center">
        <h1 className="text-3xl font-bold text-black">QUICK UI</h1>
        <p className="text-xl text-black">An UI Sound All in one for GameDev</p>
      </div>

      <div className="mb-6">
        <button 
          onClick={() => document.getElementById('fileInput').click()} 
          className="flex items-center gap-2 border border-gray-300 bg-white px-4 py-2 rounded-md hover:bg-gray-100"
        >
          <Plus size={18} /> Upload audio
        </button>
        <input 
          id="fileInput" 
          type="file" 
          accept="audio/*" 
          onChange={handleFileUpload} 
          className="hidden" 
        />
      </div>

      {/* List of audio tracks */}
      <div className="space-y-4">
        {audioTracks.map((track, index) => (
          <div key={track.id} className="flex flex-wrap gap-4 items-center">
            {/* Track name */}
            <div className="w-48 px-4 py-2 bg-gray-200 rounded-md flex justify-between items-center">
              <span className="truncate">{track.name}</span>
              <button onClick={() => removeTrack(track.id)} className="text-gray-600 hover:text-red-500">
                <X size={18} />
              </button>
            </div>

            {/* Type selector */}
            <div className="relative">
              <div className="flex flex-col">
                <span className="text-xs text-gray-500 ml-1">Type</span>
                <div 
                  className="w-48 px-4 py-2 bg-purple-100 rounded-md flex justify-between items-center cursor-pointer"
                  onClick={() => {
                    setSelectedTrackIndex(index);
                    setShowTypeDropdown(!showTypeDropdown && selectedTrackIndex === index);
                  }}
                >
                  <span>{track.type || 'Select type'}</span>
                  <button className="text-gray-600">
                    <X size={18} />
                  </button>
                </div>
              </div>

              {/* Dropdown for type selection */}
              {showTypeDropdown && selectedTrackIndex === index && (
                <div className="absolute z-10 w-48 mt-1 bg-purple-50 rounded-md shadow-lg">
                  {soundTypes.map(type => (
                    <div 
                      key={type} 
                      className="px-4 py-2 hover:bg-purple-100 cursor-pointer"
                      onClick={() => selectType(track.id, type)}
                    >
                      {type}
                    </div>
                  ))}
                </div>
              )}
            </div>

            {/* Controls (visible after mixing) */}
            {track.mixed ? (
              <>
                {/* Volume slider */}
                <div className="flex flex-col">
                  <span className="text-xs text-gray-500 ml-1">Volume</span>
                  <input 
                    type="range" 
                    min="-40" 
                    max="0" 
                    value={track.volume} 
                    onChange={(e) => updateVolume(track.id, Number(e.target.value))}
                    className="w-48 h-2 bg-purple-100 rounded-lg appearance-none cursor-pointer"
                  />
                </div>

                {/* Play count */}
                <div className="w-16 h-10 bg-gray-200 rounded-full flex items-center justify-center">
                  <input 
                    type="number" 
                    min="1" 
                    max="10" 
                    value={loopCount[track.id] || 1} 
                    onChange={(e) => updatePlayCount(track.id, Number(e.target.value))}
                    className="w-8 bg-transparent text-center"
                  />
                </div>

                {/* Play button */}
                <button 
                  onClick={() => playSound(track.id)}
                  className={`w-10 h-10 rounded-full flex items-center justify-center ${
                    playingState[track.id] ? 'bg-red-500' : 'bg-white border border-black'
                  }`}
                >
                  <Play size={18} fill={playingState[track.id] ? "white" : "black"} />
                </button>

                {/* Stop button */}
                <button 
                  onClick={() => stopSound(track.id)}
                  className="px-6 py-2 bg-purple-100 rounded-full hover:bg-purple-200"
                >
                  <StopCircle size={18} />
                </button>

                {/* Pitch variation */}
                <div className="flex items-center space-x-2">
                  <button
                    onClick={() => addPitchVariation(track.id, -3)}
                    className="px-2 py-1 rounded hover:bg-gray-200"
                  >
                    -3
                  </button>
                  <button
                    onClick={() => addPitchVariation(track.id, -2)}
                    className="px-2 py-1 rounded hover:bg-gray-200"
                  >
                    -2
                  </button>
                  <button
                    onClick={() => addPitchVariation(track.id, -1)}
                    className="px-2 py-1 rounded hover:bg-gray-200"
                  >
                    -1
                  </button>
                  <button
                    onClick={() => addPitchVariation(track.id, 0)}
                    className="px-2 py-1 rounded hover:bg-gray-200"
                  >
                    0
                  </button>
                  <button
                    onClick={() => addPitchVariation(track.id, 1)}
                    className="px-2 py-1 rounded hover:bg-gray-200"
                  >
                    +1
                  </button>
                  <button
                    onClick={() => addPitchVariation(track.id, 2)}
                    className="px-2 py-1 rounded hover:bg-gray-200"
                  >
                    +2
                  </button>
                  <button
                    onClick={() => addPitchVariation(track.id, 3)}
                    className="px-2 py-1 rounded hover:bg-gray-200"
                  >
                    +3
                  </button>
                </div>

                {/* Export button */}
                <button 
                  onClick={() => exportSound(track.id)}
                  className="px-6 py-2 bg-gray-100 rounded-full hover:bg-gray-200"
                >
                  EXPORT
                </button>
              </>
            ) : (
              <button 
                onClick={() => activateMixMode(track.id)}
                className="px-6 py-2 bg-purple-100 rounded-full hover:bg-purple-200"
              >
                Mix it now!
              </button>
            )}
          </div>
        ))}
      </div>

      {/* Global controls */}
      {audioTracks.length > 0 && (
        <div className="flex gap-4 justify-end mt-6">
          <button 
            onClick={playAllSounds}
            className="px-6 py-2 bg-gray-200 rounded-full hover:bg-gray-300"
          >
            PLAY ALL
          </button>
          <button 
            onClick={exportAllSounds}
            className="px-6 py-2 bg-gray-200 rounded-full hover:bg-gray-300"
          >
            EXPORT ALL
          </button>
        </div>
      )}
    </div>
  );
}
